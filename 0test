#!/usr/bin/env python
# Copyright (C) 2008, Thomas Leonard
# Visit http://0install.net for details.

import os, traceback, sys
from optparse import OptionParser

sys.path.insert(0, os.environ["0TEST_ZEROINSTALL"])

from zeroinstall.injector import autopolicy, iface_cache, model, run, handler, arch

version = '0.2'

parser = OptionParser(usage="usage: %prog [INTERFACE VERSION ...] ...\n\n"
		"For example, to test three versions of 0compile against two versions of Zero Install:\n\n"
		"0test http://0install.net/2006/interfaces/0compile.xml 0.10 0.12 0.12-post \\\n"
		"      http://0install.net/2007/interfaces/ZeroInstall.xml 0.31 0.36")

parser.add_option("-t", "--test-command", help="specify a custom test command", action='store', metavar='CMD')
parser.add_option("-v", "--verbose", help="more verbose output", action='count')
parser.add_option("-V", "--version", help="display version information", action='store_true')

(options, args) = parser.parse_args()

if options.version:
	print "0test (zero-install) " + version
	print "Copyright (C) 2008 Thomas Leonard"
	print "This program comes with ABSOLUTELY NO WARRANTY,"
	print "to the extent permitted by law."
	print "You may redistribute copies of this program"
	print "under the terms of the GNU General Public License."
	print "For more information about these matters, see the file named COPYING."
	sys.exit(0)

if not args:
	parser.print_help()
	sys.exit(1)

if options.verbose:
	import logging
	logger = logging.getLogger()
	if options.verbose == 1:
		logger.setLevel(logging.INFO)
	else:
		logger.setLevel(logging.DEBUG)

passed = []
skipped = []
failed = []

test_ifaces = []
test_wrapper = options.test_command
test_matrix = {}

if test_wrapper:
	test_wrapper += ' #'

iface = None
for x in args:
	if x[0].isdigit() and iface:
		test_matrix[iface].append(x)
	else:
		assert x not in test_matrix, "Interface %s given twice!" % x
		iface = model.canonical_iface_uri(x)
		test_matrix[iface] = []
		test_ifaces.append(iface)

# We don't need to specify the version of the interface under test.
test_iface = test_ifaces[0]
if not test_matrix[test_iface]:
	del test_matrix[test_iface]

# We do need a version for all the others (else what was the point of listing them?)
for iface in test_ifaces[1:]:
	if not test_matrix[iface]:
		raise Exception("No versions given for interface %s" % iface)

class VersionRestriction(model.Restriction):
	def __init__(self, version):
		self.version = version

	def meets_restriction(self, impl):
		return impl.get_version() == self.version

	def __repr__(self):
		return "version = %s" % self.version

def get_combos(ifaces):
	if not ifaces:
		yield {}
		return
	for version in test_matrix[ifaces[0]]:
		for combo in get_combos(ifaces[1:]):
			combo[iface_cache.iface_cache.get_interface(ifaces[0])] = [VersionRestriction(version)]
			yield combo.copy()

def all_combinations():
	if test_iface in test_matrix:
		return get_combos(test_ifaces)
	else:
		return get_combos(test_ifaces[1:])

class MyHandler(handler.Handler):
	def downloads_changed(self):
		if self.monitored_downloads:
			print "Downloading... ", ', '.join(self.monitored_downloads.keys())

class TestingArchitecture(arch.Architecture):
	use = frozenset([None, "testing"])

	def __init__(self, child_arch):
		arch.Architecture.__init__(self, child_arch.os_ranks, child_arch.machine_ranks)
		self.child_arch = child_arch

ap = autopolicy.AutoPolicy(test_iface)
ap.target_arch = TestingArchitecture(ap.target_arch)
ap.handler = MyHandler()

# Explore all combinations...

tested_iface = iface_cache.iface_cache.get_interface(test_iface)

def _get_implementation_path(impl):
	return impl.local_path or iface_cache.iface_cache.stores.lookup_any(impl.digests)

def run_tests(ap):
	root_impl = ap.get_implementation(tested_iface)

	this_combo = []
	for x in ap.solver.selections:
		this_combo.append("%s v%s" % (x.get_name(), ap.solver.selections[x].get_version()))
	this_combo = ', '.join(this_combo)
	print this_combo

	if test_wrapper:
		tests_dir = None
		test_main = None
	else:
		test_main = root_impl.metadata.get("self-test", None)
		if not test_main:
			print >>sys.stderr, "No self-test for version %s" % root_impl.get_version()
			skipped.append(this_combo)
			return
		main_abs = os.path.join(_get_implementation_path(root_impl), test_main)
		if not os.path.exists(main_abs):
			print >>sys.stderr, "Test executable does not exist:", main_abs
			skipped.append(this_combo)
			return

		tests_dir = os.path.dirname(main_abs)
		test_main = '/' + test_main

	child = os.fork()
	if child:
		# We are the parent
		pid, status = os.waitpid(child, 0)
		assert pid == child
		if status == 0:
			passed.append(this_combo)
		else:
			failed.append(this_combo)
		print "Status:", hex(status)
	else:
		# We are the child
		try:
			try:
				if test_wrapper is None:
					os.chdir(tests_dir)
				run.execute(ap, [], main = test_main, wrapper = test_wrapper)
				os._exit(0)
			except model.SafeException, ex:
				print >>sys.stderr, str(ex)
			except:
				traceback.print_exc()
		finally:
			sys.stdout.flush()
			sys.stderr.flush()
			os._exit(1)

if 'DISPLAY' in os.environ and not test_wrapper:
	del os.environ['DISPLAY']

for combo in all_combinations():
	ap.solver.extra_restrictions = combo
	solve = ap.solve_with_downloads()
	ap.handler.wait_for_blocker(solve)
	if not ap.ready:
		print "Failed to find a valid set of selections for", combo
		skipped.append(' '.join('%s %s' % (iface.get_name(), restrictions[0]) for iface, restrictions in combo.items()))
		continue

	download = ap.download_uncached_implementations()
	if download:
		ap.handler.wait_for_blocker(download)

	tested_impl = ap.implementation[tested_iface]

	run_tests(ap)

def format(label, results):
	if not results:
		print "None", label
	else:
		print label.capitalize()
		for combo in results:
			print " - " + combo

print "\nSUMMARY:\n"

format("passed", passed)
format("skipped", skipped)
format("failed", failed)

if failed:
	sys.exit(1)
